一、基本概念:
1、程序：program app 如：QQ.exe;
2、进程：一个程序运行起来，如QQ running;
3、线程：一个程序中最小的执行单元，也可以理解为一个进程里面的不同执行路径;
4、协程/纤程：
5、创建线程的方式：1、继承Thread 2、实现Runnable接口
6、调用/启动线程的方式：1：Thread 2: Runnable 3:Executors.newCachedThrad
7、线程中常用的几个方法：
   1> sleep:
   2> yeild:
   3> join:
8、线程状态：new -> runnable (ready,running) -> timedWaiting/waiting/blocked -> teminated(结束后没有办法调用start再执行)
9、如何实现3个线程按顺序执行？
    方法一：在主线程中分别调用t1.join(),t2.join(),t3.join();
    方法二：在t1中调用t2.join(),在t2中调用t3.join();
10、synchronized关键字：
     1> synchronized既保证原子性，又可以保证可见性;
     2> synchronized锁的是对象不是代码，三种形式：new具体对象(不建议使用)、普通方法锁定的是this对象、静态方法锁定的是XX.class对象;
     3> synchronized(obj)时不能用String常量、Integer、Long这些基础数据类型；
11、同步方法和非同步方法是否可以同时调用？可以
12、模拟银行账户对业务写方法枷锁，对业务读方法不加锁，会不会有问题？
    答：由于同步写方法和非同步读方法可以同时运行，所以可能会造成脏读问题(dirtyRead);
13、一个同步方法可以调用另一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍
然会得到该对象的锁，即synchronized获得的锁是可重入的，如：子类b继承了a，重写了同步方法m
并且里面调用了super(),如果同步锁不可重入，会直接导致死锁。。。。
14、程序在执行过程中，默认情况下锁会被释放，所以在并发处理过程中，有异常得多加小心，不
然可能会发生不一致的情况，比如:在web app 处理过程中，多个servlet线程共同访问一个资源，这
时如果异常处理不合适，在第一个线程中抛出异常，其他线程就会进入同步代码，有可能会访问到异常
产生时的数据；
15、synchronized底层实现：
    jdk早期时synchronized实现都是重量级的，都是要通过操作系统OS来申请锁，导致效率非常低，
    后来进行改进，做了锁升级(jdk1.5之后)；
    锁升级过程(oracle虚拟机hospot的实现)，如synchronized(object) :
      1>偏向锁：在Object对象头上markword记录这个线程ID，并没有真的加锁，第一个线程进来默认不会有第二个
        线程来抢这把锁；
      2>自旋锁：如果存在了线程争用，即升级为自旋锁；
      3>重量级锁：自旋10次(默认)之后，升级为重量级锁，即需要去操作系统申请；
 注：synchronized锁其实也并不比原子性锁Atomic、lock慢，Atomic、lock的实现用的也是自旋锁，自旋锁占用cpu，
 但是不访问操作系统，所以是用户态解决加锁、解锁问题，效率要比经过内核态的要高；
16、Synchronized、Lock、Atomic三种锁的区别：
      1> Synchronized:不可中断，一旦执行到同步代码时，就必须执行完，适合竞争不激烈的情况，可读性较好，当竞争很
         激烈时，synchronize 的性能下降非常快；
      2> Lock:可中断，调用unlock()可以中断线程执行，竞争激烈时保持常态；
      3> Atomic:竞争激烈时也能维持常态，比Lock 性能好，缺点就是只能同步一个值；
17、分析什么情况下用自旋锁？什么情况下用重量级锁？
      1>加锁代码执行时间短，线程数少的情况下用自旋锁；
      2>加锁代码执行时间久，线程数多的情况下用重量级锁(系统锁)；

18、一个class文件load到内存它是不是单例的？
     一般情况下是单例的，在同一个classLoader空间里面它一定是单例的，但是不同的classLoader就不是了，不过不同加载器之间也不能互相访问，所以如果可以访问那一定就是单例；



19、volatile关键字:
    1> 保证线程可见性:本质MESI(Modified Exclusive Shared Or Invalid)是CPU的缓存一致性协议；
    2> 禁止指令重排序(CPU):通过编译器在编译生产字节码文件时，，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序，如:DCL(Double Check Lock)单例模式，实例对象不加volatile可能会发生指令重排序;
    3> 不能保证原子性，所以volatile不能替代synchronized；


20、AtomXXX类原理：
    CAS操作( Compare And Set)是指令级别操作，不能被打断
     语法： cas(V,Exception ,NewValue)
     if(V==E){
        V= New
     }else{
        try again or fail    --CPU原语支持
     }
  ABA问题：加版本号解决   A-1 B-2 A-3
   如果是基础数据类型，无所谓;
   如果是引用类型就好比跟女朋友复合，但这中间她经历过别的男生；









